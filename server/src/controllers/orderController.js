const { sequelize } = require('../config/database');
const { QueryTypes } = require('sequelize');
const { createOrderNotification, createAdminOrderNotification } = require('../utils/notifications');

const STAFF_ROLES = new Set(['admin', 'manager', 'staff']);
const CUSTOMER_MUTABLE_STATUSES = new Set(['cancelled', 'return_refund', 'completed']);

const getActiveShopMembershipRole = async (shopId, userId) => {
  if (!shopId || !userId) return null;

  const [membership] = await sequelize.query(
    `SELECT role
       FROM public.shop_members
      WHERE shop_id = :shop_id
        AND user_id = :user_id
        AND status = 'active'
      LIMIT 1`,
    {
      type: QueryTypes.SELECT,
      replacements: { shop_id: shopId, user_id: userId },
    }
  );

  return membership?.role || null;
};

const canAccessOrder = ({ actorUserId, actorRole, orderOwnerId }) => {
  if (!actorUserId) return false;
  if (STAFF_ROLES.has(actorRole)) return true;
  return Number(orderOwnerId) === Number(actorUserId);
};

const ensureStaffActor = async ({ shopId, actorUserId, errorMessage = 'Only shop staff can access this endpoint.' }) => {
  const actorRole = await getActiveShopMembershipRole(shopId, actorUserId);
  if (!STAFF_ROLES.has(actorRole)) {
    return { allowed: false, actorRole };
  }
  return { allowed: true, actorRole };
};

/**
 * Order Controller
 * Handles order creation and management operations
 */

/**
 * Create new order and update product stock
 * POST /api/orders
 */
exports.createOrder = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { 
      items, 
      total_amount, 
      first_name, 
      last_name, 
      email, 
      phone, 
      address, 
      city, 
      postal_code, 
      notes,
      payment_method = 'cash_on_delivery'
    } = req.body;
    const shopId = req.shop?.id;
    const actorUserId = req.user?.id;
    
    console.log('ðŸ”„ Creating new order...');

    // Validate required fields
    if (!actorUserId || !items || !Array.isArray(items) || items.length === 0) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: items'
      });
    }

    // Validate delivery info fields
    if (!first_name || !last_name || !email || !phone || !address || !city || !postal_code) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Missing required delivery information: first_name, last_name, email, phone, address, city, postal_code'
      });
    }

    // Generate order number (will be auto-generated by trigger, but we can set it manually too)
    const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;

    // Create order with all required fields matching the database schema
    const [newOrder] = await sequelize.query(
      `INSERT INTO public.orders 
       (shop_id, user_id, order_number, first_name, last_name, email, phone, address, city, postal_code, notes, payment_method, status, total_amount, created_at, updated_at)
       VALUES (:shop_id, :user_id, :order_number, :first_name, :last_name, :email, :phone, :address, :city, :postal_code, :notes, :payment_method, 'pending', :total_amount, NOW(), NOW())
       RETURNING *`,
      { 
        type: QueryTypes.SELECT,
        replacements: {
          shop_id: shopId,
          user_id: actorUserId,
          order_number: orderNumber,
          first_name,
          last_name,
          email,
          phone,
          address,
          city,
          postal_code,
          notes: notes || null,
          payment_method,
          total_amount
        },
        transaction
      }
    );

    // Create order items and update product stock
    for (const item of items) {
      const { product_id, quantity, price } = item;

      // Validate item
      if (!product_id || !quantity || !price) {
        await transaction.rollback();
        return res.status(400).json({
          success: false,
          message: 'Each item must have product_id, quantity, and price'
        });
      }

      // Check if product exists and has enough stock
      const [product] = await sequelize.query(
        `SELECT id, name, quantity FROM public.products WHERE id = :product_id AND shop_id = :shop_id`,
        { 
          type: QueryTypes.SELECT,
          replacements: { product_id, shop_id: shopId },
          transaction
        }
      );

      if (!product) {
        await transaction.rollback();
        return res.status(400).json({
          success: false,
          message: `Product with ID ${product_id} not found`
        });
      }

      if (product.quantity < quantity) {
        await transaction.rollback();
        return res.status(400).json({
          success: false,
          message: `Insufficient stock for ${product.name}. Available: ${product.quantity}, Requested: ${quantity}`
        });
      }

      // Create order item (order_items table doesn't have updated_at column)
      await sequelize.query(
        `INSERT INTO public.order_items 
         (shop_id, order_id, product_id, quantity, price, created_at)
         VALUES (:shop_id, :order_id, :product_id, :quantity, :price, NOW())`,
        { 
          type: QueryTypes.INSERT,
          replacements: {
            shop_id: shopId,
            order_id: newOrder.id,
            product_id,
            quantity,
            price
          },
          transaction
        }
      );

      // Update product stock
      await sequelize.query(
        `UPDATE public.products 
         SET quantity = quantity - :quantity, updated_at = NOW()
         WHERE id = :product_id AND shop_id = :shop_id`,
        { 
          type: QueryTypes.UPDATE,
          replacements: {
            product_id,
            quantity,
            shop_id: shopId
          },
          transaction
        }
      );

      console.log(`âœ… Updated stock for product ${product_id}: -${quantity}`);
    }

    // Commit transaction
    await transaction.commit();

    // Create notification for the user about their new order
    const customerName = `${first_name} ${last_name}`;

    try {
      await Promise.all([
        createOrderNotification(
          actorUserId,
          newOrder.order_number,
          newOrder.id,
          'pending',
          newOrder.total_amount,
          shopId
        ),
        createAdminOrderNotification({
          orderNumber: newOrder.order_number,
          orderId: newOrder.id,
          totalAmount: newOrder.total_amount,
          customerName,
          event: 'new_order',
          shopId,
        }),
      ]);
    } catch (notifError) {
      // Don't fail the order creation if notification fails
      console.warn('âš ï¸ Failed to create order notification:', notifError.message);
    }

    res.status(201).json({
      success: true,
      message: 'Order created successfully',
      data: {
        id: newOrder.id,
        order_number: newOrder.order_number,
        total_amount: newOrder.total_amount,
        status: newOrder.status,
        created_at: newOrder.created_at
      }
    });

    console.log(`âœ… Order created successfully: ${orderNumber}`);

  } catch (error) {
    await transaction.rollback();
    console.error('âŒ Create order error:', error.message);
    console.error('âŒ Error stack:', error.stack);
    console.error('âŒ Request body:', JSON.stringify(req.body, null, 2));
    res.status(500).json({
      success: false,
      message: 'Failed to create order',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Get orders for a specific user
 * GET /api/orders/user/:userId
 */
exports.getUserOrders = async (req, res) => {
  try {
    const { userId } = req.params;
    console.log(`ðŸ”„ Fetching orders for user ${userId}...`);

    const shopId = req.shop?.id;
    const actorUserId = req.user?.id;
    const actorRole = await getActiveShopMembershipRole(shopId, actorUserId);
    const isOwnOrders = Number(userId) === Number(actorUserId);

    if (!isOwnOrders && !STAFF_ROLES.has(actorRole)) {
      return res.status(403).json({
        success: false,
        message: 'Access denied. You can only view your own orders.'
      });
    }

    const orders = await sequelize.query(
      `SELECT 
        o.id,
        o.user_id,
        o.order_number,
        o.total_amount,
        o.status,
        o.address,
        o.city,
        o.postal_code,
        o.created_at,
        o.updated_at,
        COUNT(oi.id) as item_count
      FROM public.orders o
      LEFT JOIN public.order_items oi ON oi.order_id = o.id
      WHERE o.user_id = :userId AND o.shop_id = :shop_id
      GROUP BY o.id, o.order_number, o.total_amount, o.status, o.address, o.city, o.postal_code, o.created_at, o.updated_at
      ORDER BY o.created_at DESC`,
      { 
        type: QueryTypes.SELECT,
        replacements: { userId, shop_id: shopId }
      }
    );

    res.status(200).json({
      success: true,
      data: orders
    });

    console.log(`âœ… Retrieved ${orders.length} orders for user ${userId}`);

  } catch (error) {
    console.error('âŒ Get user orders error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders'
    });
  }
};

/**
 * Get all orders for shop staff
 * GET /api/orders
 */
exports.getAllOrders = async (req, res) => {
  try {
    const shopId = req.shop?.id;
    const actorUserId = req.user?.id;
    const { allowed } = await ensureStaffActor({
      shopId,
      actorUserId,
      errorMessage: 'Only shop staff can view all orders.',
    });

    if (!allowed) {
      return res.status(403).json({
        success: false,
        message: 'Only shop staff can view all orders.',
      });
    }

    console.log(`ðŸ”„ Fetching all orders for shop ${shopId}...`);

    const orders = await sequelize.query(
      `SELECT
         o.id,
         o.user_id,
         o.order_number,
         o.total_amount,
         o.status,
         o.first_name,
         o.last_name,
         o.email,
         o.phone,
         o.address,
         o.city,
         o.postal_code,
         o.notes,
         o.payment_method,
         o.created_at,
         o.updated_at,
         COUNT(oi.id)::int AS item_count
       FROM public.orders o
       LEFT JOIN public.order_items oi ON oi.order_id = o.id
       WHERE o.shop_id = :shop_id
       GROUP BY
         o.id, o.user_id, o.order_number, o.total_amount, o.status,
         o.first_name, o.last_name, o.email, o.phone, o.address,
         o.city, o.postal_code, o.notes, o.payment_method, o.created_at, o.updated_at
       ORDER BY o.created_at DESC`,
      {
        type: QueryTypes.SELECT,
        replacements: { shop_id: shopId },
      }
    );

    return res.status(200).json({
      success: true,
      data: orders,
    });
  } catch (error) {
    console.error('âŒ Get all orders error:', error.message);
    return res.status(500).json({
      success: false,
      message: 'Failed to fetch orders',
    });
  }
};

/**
 * Get single order with items
 * GET /api/orders/:id
 */
exports.getOrderById = async (req, res) => {
  try {
    const { id } = req.params;
    const shopId = req.shop?.id;
    const actorUserId = req.user?.id;
    const actorRole = await getActiveShopMembershipRole(shopId, actorUserId);
    console.log(`ðŸ”„ Fetching order ${id}...`);

    // Get order details
    const [order] = await sequelize.query(
      `SELECT 
        o.id,
        o.user_id,
        o.order_number,
        o.total_amount,
        o.status,
        o.first_name,
        o.last_name,
        o.email,
        o.phone,
        o.address,
        o.city,
        o.postal_code,
        o.notes,
        o.payment_method,
        o.created_at,
        o.updated_at
      FROM public.orders o
      WHERE o.id = :id AND o.shop_id = :shop_id`,
      { 
        type: QueryTypes.SELECT,
        replacements: { id, shop_id: shopId }
      }
    );

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    if (!canAccessOrder({ actorUserId, actorRole, orderOwnerId: order.user_id })) {
      return res.status(403).json({
        success: false,
        message: 'Access denied. You can only view your own orders.'
      });
    }

    // Get order items
    const items = await sequelize.query(
      `SELECT 
        oi.id,
        oi.product_id,
        oi.quantity,
        oi.price,
        p.name as product_name,
        p.category as product_category,
        pi.image_url as product_image
      FROM public.order_items oi
      JOIN public.products p ON p.id = oi.product_id
      LEFT JOIN public.product_images pi
        ON pi.product_id = oi.product_id
       AND pi.is_primary = true
      WHERE oi.order_id = :id AND oi.shop_id = :shop_id`,
      { 
        type: QueryTypes.SELECT,
        replacements: { id, shop_id: shopId }
      }
    );

    res.status(200).json({
      success: true,
      data: {
        ...order,
        items
      }
    });

    console.log(`âœ… Retrieved order ${id} with ${items.length} items`);

  } catch (error) {
    console.error('âŒ Get order error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch order'
    });
  }
};

/**
 * Update order status
 * PUT /api/orders/:id/status
 */
exports.updateOrderStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const shopId = req.shop?.id;
    const actorUserId = req.user?.id;
    const actorRole = await getActiveShopMembershipRole(shopId, actorUserId);
    const isStaffActor = STAFF_ROLES.has(actorRole);
    
    console.log(`ðŸ”„ Updating order ${id} status to ${status}...`);

    if (!status) {
      return res.status(400).json({
        success: false,
        message: 'Status is required'
      });
    }

    const validStatuses = ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'completed', 'cancelled', 'return_refund'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: `Invalid status. Must be one of: ${validStatuses.join(', ')}`
      });
    }

    const [existingOrder] = await sequelize.query(
      `SELECT id, user_id, order_number, first_name, last_name, total_amount
       FROM public.orders
       WHERE id = :id AND shop_id = :shop_id
       LIMIT 1`,
      {
        type: QueryTypes.SELECT,
        replacements: { id, shop_id: shopId }
      }
    );

    if (!existingOrder) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    if (!canAccessOrder({ actorUserId, actorRole, orderOwnerId: existingOrder.user_id })) {
      return res.status(403).json({
        success: false,
        message: 'Access denied. You can only update your own order.'
      });
    }

    if (!isStaffActor && !CUSTOMER_MUTABLE_STATUSES.has(status)) {
      return res.status(403).json({
        success: false,
        message: 'Only shop staff can set this status.'
      });
    }

    const [updatedOrder] = await sequelize.query(
      `UPDATE public.orders 
       SET status = :status, updated_at = NOW()
       WHERE id = :id AND shop_id = :shop_id
       RETURNING *`,
      { 
        type: QueryTypes.SELECT,
        replacements: { id, status, shop_id: shopId }
      }
    );

    // Create notification for the user about order status update
    try {
      await createOrderNotification(
        updatedOrder.user_id,
        updatedOrder.order_number,
        updatedOrder.id,
        status,
        updatedOrder.total_amount,
        shopId
      );

      // Notify admins only when the event was triggered by the customer (cancel/return)
      if (['cancelled', 'return_refund'].includes(status)) {
        await createAdminOrderNotification({
          orderNumber: updatedOrder.order_number,
          orderId: updatedOrder.id,
          totalAmount: updatedOrder.total_amount,
          customerName: `${updatedOrder.first_name} ${updatedOrder.last_name}`,
          event: status,
          shopId,
        });
      }
    } catch (notifError) {
      // Don't fail the status update if notification fails
      console.warn('âš ï¸ Failed to create status update notification:', notifError.message);
    }

    res.status(200).json({
      success: true,
      message: 'Order status updated successfully',
      data: updatedOrder
    });

    console.log(`âœ… Updated order ${id} status to ${status}`);

  } catch (error) {
    console.error('âŒ Update order status error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to update order status'
    });
  }
};

/**
 * Delete order (staff only)
 * DELETE /api/orders/:id
 */
exports.deleteOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const shopId = req.shop?.id;
    const actorUserId = req.user?.id;
    const { allowed } = await ensureStaffActor({
      shopId,
      actorUserId,
      errorMessage: 'Only shop staff can delete orders.',
    });

    if (!allowed) {
      return res.status(403).json({
        success: false,
        message: 'Only shop staff can delete orders.',
      });
    }

    const deleted = await sequelize.query(
      `DELETE FROM public.orders
       WHERE id = :id
         AND shop_id = :shop_id`,
      {
        type: QueryTypes.DELETE,
        replacements: { id, shop_id: shopId },
      }
    );

    if (!deleted || (Array.isArray(deleted) && deleted[1] === 0)) {
      return res.status(404).json({
        success: false,
        message: 'Order not found',
      });
    }

    return res.status(200).json({
      success: true,
      message: 'Order deleted successfully',
    });
  } catch (error) {
    console.error('âŒ Delete order error:', error.message);
    return res.status(500).json({
      success: false,
      message: 'Failed to delete order',
    });
  }
};

/**
 * Delete completed/cancelled orders older than retention days (staff only)
 * DELETE /api/orders/cleanup/completed?retentionDays=30
 */
exports.deleteCompletedOrders = async (req, res) => {
  try {
    const shopId = req.shop?.id;
    const actorUserId = req.user?.id;
    const { allowed } = await ensureStaffActor({
      shopId,
      actorUserId,
      errorMessage: 'Only shop staff can cleanup orders.',
    });

    if (!allowed) {
      return res.status(403).json({
        success: false,
        message: 'Only shop staff can cleanup orders.',
      });
    }

    const rawRetention = Number(req.query.retentionDays);
    const retentionDays = Number.isFinite(rawRetention)
      ? Math.min(Math.max(rawRetention, 1), 3650)
      : 30;

    const deletedRows = await sequelize.query(
      `DELETE FROM public.orders
       WHERE shop_id = :shop_id
         AND status IN ('delivered', 'cancelled')
         AND updated_at < (NOW() - (:retention_days || ' days')::interval)
       RETURNING id`,
      {
        type: QueryTypes.SELECT,
        replacements: {
          shop_id: shopId,
          retention_days: String(retentionDays),
        },
      }
    );

    return res.status(200).json({
      success: true,
      message: 'Completed orders cleaned up successfully',
      data: { deletedCount: deletedRows.length, retentionDays },
    });
  } catch (error) {
    console.error('âŒ Delete completed orders error:', error.message);
    return res.status(500).json({
      success: false,
      message: 'Failed to cleanup completed orders',
    });
  }
};
