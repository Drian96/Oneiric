const { sequelize } = require('../config/database');
const { QueryTypes } = require('sequelize');
const { createOrderNotification, createAdminOrderNotification } = require('../utils/notifications');

/**
 * Order Controller
 * Handles order creation and management operations
 */

/**
 * Create new order and update product stock
 * POST /api/orders
 */
exports.createOrder = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { 
      user_id, 
      items, 
      total_amount, 
      first_name, 
      last_name, 
      email, 
      phone, 
      address, 
      city, 
      postal_code, 
      notes,
      payment_method = 'cash_on_delivery'
    } = req.body;
    const shopId = req.shop?.id;
    
    console.log('üîÑ Creating new order...');

    // Validate required fields
    if (!user_id || !items || !Array.isArray(items) || items.length === 0) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: user_id, items'
      });
    }

    // Validate delivery info fields
    if (!first_name || !last_name || !email || !phone || !address || !city || !postal_code) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Missing required delivery information: first_name, last_name, email, phone, address, city, postal_code'
      });
    }

    // Generate order number (will be auto-generated by trigger, but we can set it manually too)
    const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;

    // Create order with all required fields matching the database schema
    const [newOrder] = await sequelize.query(
      `INSERT INTO public.orders 
       (shop_id, user_id, order_number, first_name, last_name, email, phone, address, city, postal_code, notes, payment_method, status, total_amount, created_at, updated_at)
       VALUES (:shop_id, :user_id, :order_number, :first_name, :last_name, :email, :phone, :address, :city, :postal_code, :notes, :payment_method, 'pending', :total_amount, NOW(), NOW())
       RETURNING *`,
      { 
        type: QueryTypes.SELECT,
        replacements: {
          shop_id: shopId,
          user_id,
          order_number: orderNumber,
          first_name,
          last_name,
          email,
          phone,
          address,
          city,
          postal_code,
          notes: notes || null,
          payment_method,
          total_amount
        },
        transaction
      }
    );

    // Create order items and update product stock
    for (const item of items) {
      const { product_id, quantity, price } = item;

      // Validate item
      if (!product_id || !quantity || !price) {
        await transaction.rollback();
        return res.status(400).json({
          success: false,
          message: 'Each item must have product_id, quantity, and price'
        });
      }

      // Check if product exists and has enough stock
      const [product] = await sequelize.query(
        `SELECT id, name, quantity FROM public.products WHERE id = :product_id AND shop_id = :shop_id`,
        { 
          type: QueryTypes.SELECT,
          replacements: { product_id, shop_id: shopId },
          transaction
        }
      );

      if (!product) {
        await transaction.rollback();
        return res.status(400).json({
          success: false,
          message: `Product with ID ${product_id} not found`
        });
      }

      if (product.quantity < quantity) {
        await transaction.rollback();
        return res.status(400).json({
          success: false,
          message: `Insufficient stock for ${product.name}. Available: ${product.quantity}, Requested: ${quantity}`
        });
      }

      // Create order item (order_items table doesn't have updated_at column)
      await sequelize.query(
        `INSERT INTO public.order_items 
         (shop_id, order_id, product_id, quantity, price, created_at)
         VALUES (:shop_id, :order_id, :product_id, :quantity, :price, NOW())`,
        { 
          type: QueryTypes.INSERT,
          replacements: {
            shop_id: shopId,
            order_id: newOrder.id,
            product_id,
            quantity,
            price
          },
          transaction
        }
      );

      // Update product stock
      await sequelize.query(
        `UPDATE public.products 
         SET quantity = quantity - :quantity, updated_at = NOW()
         WHERE id = :product_id AND shop_id = :shop_id`,
        { 
          type: QueryTypes.UPDATE,
          replacements: {
            product_id,
            quantity,
            shop_id: shopId
          },
          transaction
        }
      );

      console.log(`‚úÖ Updated stock for product ${product_id}: -${quantity}`);
    }

    // Commit transaction
    await transaction.commit();

    // Create notification for the user about their new order
    const customerName = `${first_name} ${last_name}`;

    try {
      await Promise.all([
        createOrderNotification(
          user_id,
          newOrder.order_number,
          newOrder.id,
          'pending',
          newOrder.total_amount,
          shopId
        ),
        createAdminOrderNotification({
          orderNumber: newOrder.order_number,
          orderId: newOrder.id,
          totalAmount: newOrder.total_amount,
          customerName,
          event: 'new_order',
          shopId,
        }),
      ]);
    } catch (notifError) {
      // Don't fail the order creation if notification fails
      console.warn('‚ö†Ô∏è Failed to create order notification:', notifError.message);
    }

    res.status(201).json({
      success: true,
      message: 'Order created successfully',
      data: {
        id: newOrder.id,
        order_number: newOrder.order_number,
        total_amount: newOrder.total_amount,
        status: newOrder.status,
        created_at: newOrder.created_at
      }
    });

    console.log(`‚úÖ Order created successfully: ${orderNumber}`);

  } catch (error) {
    await transaction.rollback();
    console.error('‚ùå Create order error:', error.message);
    console.error('‚ùå Error stack:', error.stack);
    console.error('‚ùå Request body:', JSON.stringify(req.body, null, 2));
    res.status(500).json({
      success: false,
      message: 'Failed to create order',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Get orders for a specific user
 * GET /api/orders/user/:userId
 */
exports.getUserOrders = async (req, res) => {
  try {
    const { userId } = req.params;
    console.log(`üîÑ Fetching orders for user ${userId}...`);

    const shopId = req.shop?.id;
    const orders = await sequelize.query(
      `SELECT 
        o.id,
        o.order_number,
        o.total_amount,
        o.status,
        o.address,
        o.city,
        o.postal_code,
        o.created_at,
        o.updated_at,
        COUNT(oi.id) as item_count
      FROM public.orders o
      LEFT JOIN public.order_items oi ON oi.order_id = o.id
      WHERE o.user_id = :userId AND o.shop_id = :shop_id
      GROUP BY o.id, o.order_number, o.total_amount, o.status, o.address, o.city, o.postal_code, o.created_at, o.updated_at
      ORDER BY o.created_at DESC`,
      { 
        type: QueryTypes.SELECT,
        replacements: { userId, shop_id: shopId }
      }
    );

    res.status(200).json({
      success: true,
      data: orders
    });

    console.log(`‚úÖ Retrieved ${orders.length} orders for user ${userId}`);

  } catch (error) {
    console.error('‚ùå Get user orders error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders'
    });
  }
};

/**
 * Get single order with items
 * GET /api/orders/:id
 */
exports.getOrderById = async (req, res) => {
  try {
    const { id } = req.params;
    const shopId = req.shop?.id;
    console.log(`üîÑ Fetching order ${id}...`);

    // Get order details
    const [order] = await sequelize.query(
      `SELECT 
        o.id,
        o.order_number,
        o.total_amount,
        o.status,
        o.first_name,
        o.last_name,
        o.email,
        o.phone,
        o.address,
        o.city,
        o.postal_code,
        o.notes,
        o.payment_method,
        o.created_at,
        o.updated_at
      FROM public.orders o
      WHERE o.id = :id AND o.shop_id = :shop_id`,
      { 
        type: QueryTypes.SELECT,
        replacements: { id, shop_id: shopId }
      }
    );

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Get order items
    const items = await sequelize.query(
      `SELECT 
        oi.id,
        oi.product_id,
        oi.quantity,
        oi.price,
        p.name as product_name,
        p.category as product_category
      FROM public.order_items oi
      JOIN public.products p ON p.id = oi.product_id
      WHERE oi.order_id = :id AND oi.shop_id = :shop_id`,
      { 
        type: QueryTypes.SELECT,
        replacements: { id, shop_id: shopId }
      }
    );

    res.status(200).json({
      success: true,
      data: {
        ...order,
        items
      }
    });

    console.log(`‚úÖ Retrieved order ${id} with ${items.length} items`);

  } catch (error) {
    console.error('‚ùå Get order error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch order'
    });
  }
};

/**
 * Update order status
 * PUT /api/orders/:id/status
 */
exports.updateOrderStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const shopId = req.shop?.id;
    
    console.log(`üîÑ Updating order ${id} status to ${status}...`);

    if (!status) {
      return res.status(400).json({
        success: false,
        message: 'Status is required'
      });
    }

    const validStatuses = ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'completed', 'cancelled', 'return_refund'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: `Invalid status. Must be one of: ${validStatuses.join(', ')}`
      });
    }

    const [updatedOrder] = await sequelize.query(
      `UPDATE public.orders 
       SET status = :status, updated_at = NOW()
       WHERE id = :id AND shop_id = :shop_id
       RETURNING *`,
      { 
        type: QueryTypes.SELECT,
        replacements: { id, status, shop_id: shopId }
      }
    );

    if (!updatedOrder) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Create notification for the user about order status update
    try {
      await createOrderNotification(
        updatedOrder.user_id,
        updatedOrder.order_number,
        updatedOrder.id,
        status,
        updatedOrder.total_amount,
        shopId
      );

      // Notify admins only when the event was triggered by the customer (cancel/return)
      if (['cancelled', 'return_refund'].includes(status)) {
        await createAdminOrderNotification({
          orderNumber: updatedOrder.order_number,
          orderId: updatedOrder.id,
          totalAmount: updatedOrder.total_amount,
          customerName: `${updatedOrder.first_name} ${updatedOrder.last_name}`,
          event: status,
          shopId,
        });
      }
    } catch (notifError) {
      // Don't fail the status update if notification fails
      console.warn('‚ö†Ô∏è Failed to create status update notification:', notifError.message);
    }

    res.status(200).json({
      success: true,
      message: 'Order status updated successfully',
      data: updatedOrder
    });

    console.log(`‚úÖ Updated order ${id} status to ${status}`);

  } catch (error) {
    console.error('‚ùå Update order status error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to update order status'
    });
  }
};
